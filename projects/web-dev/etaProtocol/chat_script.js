// --------------- Configuration --------------- \\

let API_URL_Groq = "https://api.groq.com/openai/v1/chat/completions";
let API_KEY_Groq =  $API_KEY_1;
let AI_MODEL_Groq = "qwen-qwq-32b";
let AI_SYSTEM_PROMPT_Groq = `Identity: You are the Reasoning AI, the first stage in a coding and algorithm generation chain. Your primary role is to deeply understand, analyze, and structure the user's initial request.

    Input: You will receive the raw, potentially ambiguous or complex user request regarding a coding task, algorithm design, or technical problem.

    Task:

        Fully comprehend the user's intent and requirements.

        Break down the request into smaller, manageable components.

        Identify any ambiguities or missing information and make reasonable assumptions or note them.

        Formulate a clear, detailed plan or a refined prompt that the next AI (Execution) can follow precisely. This plan should outline the steps needed to fulfill the request, specifying the desired output format (e.g., Python code, pseudocode, algorithm description, explanation).

        Ensure the plan is logically sound and addresses all aspects of the original request.

    Output Format: A structured text output. Start with a summary of the refined request, followed by a numbered or bulleted list detailing the plan/instructions for the Execution AI. Be explicit about what needs to be generated.

    Constraints:

        Do not write any code or generate the final solution yourself.

        Do not review or evaluate potential output.

        Focus solely on understanding, planning, and preparing clear instructions for the next stage.

    Handoff: Your output is the sole input for the Execution AI.`;

let API_KEY_Google = $API_KEY_2;
let AI_MODEL_Google = "gemini-2.5-flash-preview-05-20"; // "gemini-2.0-flash";
let AI_SYSTEM_PROMPT_Google = `Identity: You are the Execution AI, the second stage in a coding and algorithm generation chain. Your primary role is to implement the detailed plan provided by the previous stage.

    Input: You will receive a detailed plan or refined prompt generated by the Reasoning AI. This input clearly specifies what needs to be created (e.g., specific code function, algorithm steps, technical explanation).

    Task:

        Strictly follow the instructions provided in the input plan.

        Generate the requested output (code, algorithm description, explanation, etc.).

        Aim for accuracy based on the plan, using appropriate syntax, logic, or descriptive language as required by the task.

    Output Format: The generated code, algorithm description, technical explanation, or other content as specified by the input plan. Include any necessary context (like language used for code).

    Constraints:

        Do not deviate from or modify the input plan.

        Do not question or critique the plan's logic or the original request.

        Do not review or evaluate the quality or correctness of your own output.

        Do not add explanations or context beyond what's required to present the output itself, unless explicitly requested in the plan.

    Handoff: Your output is the primary input for the Review AI.`;
let API_URL_Google = `https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL_Google}:generateContent?key=${API_KEY_Google}`;

let API_URL_DeepSeek = "https://openrouter.ai/api/v1/chat/completions";
let API_KEY_DeepSeek =
  $API_KEY_3;
let AI_MODEL_DeepSeek = "deepseek/deepseek-chat-v3-0324:free";
let AI_SYSTEM_PROMPT_DeepSeek = `Identity: You are the Review AI, the third stage in a coding and algorithm generation chain. Your primary role is to evaluate the output generated by the Execution AI.

    Input: You will receive the generated content (code, algorithm description, etc.) from the Execution AI. You should assume this content was generated based on a prior plan derived from a user request (though you don't see the original request directly).

    Task:

        Critically analyze the provided content for correctness, completeness, clarity, efficiency, and adherence to typical best practices for the given task (e.g., code quality, algorithmic soundness).

        Identify any errors, bugs, inefficiencies, or areas for improvement.

        Provide specific, actionable feedback detailing what is wrong or what could be improved.

        If the output is satisfactory and requires no significant changes, state that it is acceptable.

    Output Format: A structured review report.

        Start by stating whether the output is acceptable or requires revisions.

        If revisions are needed, provide a clear list of specific issues found and suggested corrections or improvements.

        If acceptable, simply state "Review: Acceptable."

        At the end of the review provide the full code.

    Constraints:

        Do not modify or fix the content yourself.

        Do not try to understand the original user request or the Reasoning plan; evaluate only the provided output based on general quality standards for coding/algorithms.

        Focus on identifying problems and describing them clearly for the next AI (Enhancer).

    Handoff: Your output (the review report) and the Code output will be passed to the Enhancer AI.`;

const DELAY_BETWEEN_CALLS_MS = 1000;

// --------------- API ENDPOINT --------------- \\

async function callAPIEndpoint(
  type,
  model,
  apiKey,
  apiURL,
  prompt,
  systemPrompt
) {
  if (type === "groq") {
    // <=== Groq ===>
    const headers = {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    };

    const requestBody = {
      model: model,
      messages: [
        {
          role: "system",
          content: systemPrompt,
        },
        {
          role: "user",
          content: prompt,
        },
      ],
    };

    try {
      const response = await fetch(apiURL, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(
          `HTTP error! status: ${response.status}, body: ${errorBody}`
        );
      }

      const responseData = await response.json();

      return responseData;
    } catch (error) {
      console.error("Error calling API:", error);
    }
  } else if (type === "google") {
    // <=== Google ===>
    const headers = {
      "Content-Type": "application/json",
    };

    const requestBody = {
      system_instruction: {
        parts: [
          {
            text: systemPrompt,
          },
        ],
      },
      contents: [
        {
          parts: [
            {
              text: prompt,
            },
          ],
        },
      ],
    };

    try {
      const response = await fetch(apiURL, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(
          `HTTP error! status: ${response.status}, body: ${errorBody}`
        );
      }

      const responseData = await response.json();

      return responseData;
    } catch (error) {
      console.error("Error calling API:", error);
    }
  } else if (type === "deepseek") {
    // <=== DeepSeek ===>
    const headers = {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    };

    const requestBody = {
      model: model,
      messages: [
        {
          role: "system",
          content: systemPrompt,
        },
        {
          role: "user",
          content: prompt,
        },
      ],
    };

    try {
      const response = await fetch(apiURL, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(requestBody),
      });

      const responseData = await response.json();

      return responseData;
    } catch (error) {
      console.error("Error calling API:", error);
    }
  }
}

// --------------- Wait Function --------------- \\

function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// --------------- API CHAIN --------------- \\

async function callAPIChain(prompt) {
  let answer = prompt;
  answer = await callAPIEndpoint(
    "groq",
    AI_MODEL_Groq,
    API_KEY_Groq,
    API_URL_Groq,
    answer,
    AI_SYSTEM_PROMPT_Groq
  );
  answer = answer.choices[0].message.content;
  console.log(answer);

  console.log(`Waiting for ${DELAY_BETWEEN_CALLS_MS / 1000} seconds...`);
  await wait(DELAY_BETWEEN_CALLS_MS);

  answer = await callAPIEndpoint(
    "google",
    AI_MODEL_Google,
    API_KEY_Google,
    API_URL_Google,
    prompt + answer,
    AI_SYSTEM_PROMPT_Google
  );
  answer = answer.candidates[0].content.parts[0].text;
  console.log(answer);

  console.log(`Waiting for ${DELAY_BETWEEN_CALLS_MS / 1000} seconds...`);
  await wait(DELAY_BETWEEN_CALLS_MS);

  answer = await callAPIEndpoint(
    "google",
    AI_MODEL_Google,
    API_KEY_Google,
    API_URL_Google,
    prompt + answer,
    AI_SYSTEM_PROMPT_Google
  );
  answer = answer.candidates[0].content.parts[0].text;
  //answer = answer.choices[0].message.content;
  console.log(answer);

  console.log(`Waiting for ${DELAY_BETWEEN_CALLS_MS / 1000} seconds...`);
  await wait(DELAY_BETWEEN_CALLS_MS);

  answer = await callAPIEndpoint(
    "google",
    AI_MODEL_Google,
    API_KEY_Google,
    API_URL_Google,
    prompt + answer,
    AI_SYSTEM_PROMPT_Google
  );
  answer = answer.candidates[0].content.parts[0].text;
  console.log(answer);

  const completeThinkBlockRegex = /<think>[\s\S]*?<\/think>/gi;
  const looseThinkTagRegex = /<\/?think>/gi;
  answer = answer.replace(completeThinkBlockRegex, "");
  answer = answer.replace(looseThinkTagRegex, "");
  answer = answer.trim();

  return answer;
}

// --------------- UI --------------- \\

document.addEventListener("DOMContentLoaded", () => {
  const inputField = document.getElementById("main-input");
  const answerDiv = document.getElementById("answer-text");
  const inputAreaContainer = document.getElementById("input-area-container");

  if (inputField && answerDiv && inputAreaContainer) {
    inputField.addEventListener("keydown", async function (event) {
      if (event.key === "Enter") {
        const inputValue = this.value.trim();

        if (inputValue !== "") {
          answerDiv.textContent = "Thinking...";
          answerDiv.style.display = "block";
          inputAreaContainer.classList.add("answer-visible");
          inputField.style.borderRadius = "0 0 8px 8px";
          inputAreaContainer.style.borderRadius = "8px";

          let generatedAnswer = await callAPIChain(inputValue);
          answerDiv.textContent = generatedAnswer;
        } else {
          answerDiv.style.display = "none";
          answerDiv.textContent = "";
          inputAreaContainer.classList.remove("answer-visible");
          inputField.style.borderRadius = "8px";
          inputAreaContainer.style.borderRadius = "8px";
        }
      }
    });
  } else {
    console.error("One or more required elements not found!");
  }
});
